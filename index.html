<!DOCTYPE html>
<html lang="en">
<head>
<!-- jQuery -->
<script src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
<!-- bootstrap -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap-theme.min.css">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/js/bootstrap.min.js"></script>

<link rel="stylesheet" href="screen.css">
<script>
$('document').ready(function () {
  // Constants
  // ms between game steps
  var FRAME_SPEED_MS = 200;
  // Number of features across the game field
  var LOGICAL_GAME_SIZE = 100;
  // Player's client spawns a new apple every this many ms
  var APPLE_INTERVAL_MS = 5000;


  // init
//      scaleCanvas();

  var lastKeystroke;
  $('html').keydown(function (e) {
    lastKeystroke = e.which;
  });

  var playerState = {};

  initGame();
  
  function initGame() {
    playerState = {
      alive: true,
      snakeDirection: "e",
      snakePieces: [],
      apples: [],
      untilNextApple: APPLE_INTERVAL_MS,
      isDead: false
    };

    playerState.apples.push(getRandomUnusedLocation(playerState));
    playerState.snakePieces.push(getRandomUnusedLocation(playerState));
    growSnake(playerState);
    growSnake(playerState);

    // Start the game
    gameLoop();
  }


  function gameLoop() {
    var $gameCanvas = $("#game-canvas");
    var gameContext = $gameCanvas.get(0).getContext("2d");
    var canvasSize = $gameCanvas.width();
    var featureSize = canvasSize / LOGICAL_GAME_SIZE;

    // process key input
    switch (lastKeystroke) {
      case 32: //TODO remove (fake apple)
        growSnake(playerState);
        break;
      case 38:
        if (playerState.snakeDirection != "s") {
          playerState.snakeDirection = "n";
        }
        break;
      case 39:
        if (playerState.snakeDirection != "w") {
          playerState.snakeDirection = "e";
        }
        break;
      case 40:
        if (playerState.snakeDirection != "n") {
          playerState.snakeDirection = "s";
        }
        break;
      case 37:
        if (playerState.snakeDirection != "e") {
          playerState.snakeDirection = "w";
        }
    }
    lastKeystroke = 0;
    // Move the player's snake

    // Remove last element
    playerState.snakePieces.pop();
    
    // Create a new first element
    var newPiece = {};
    newPiece.x = playerState.snakePieces[0].x;
    newPiece.y = playerState.snakePieces[0].y;
    
    switch (playerState.snakeDirection) {
      case "n":
        newPiece.y -= 1;
        break;
      case "e":
        newPiece.x += 1;
        break;
      case "s":
        newPiece.y += 1;
        break;
      case "w":
        newPiece.x -= 1;
    }
    playerState.snakePieces.unshift(newPiece);

    // Spawn apples
    if (playerState.untilNextApple > 0) {
      playerState.untilNextApple -= FRAME_SPEED_MS;
    } else {
      playerState.apples.push(getRandomUnusedLocation(playerState));
      playerState.untilNextApple = APPLE_INTERVAL_MS;
    }

    // If the player went off the edge, end their game
    var snakeHead = playerState.snakePieces[0];
    if(snakeHead.x <= 0 || snakeHead.x >= LOGICAL_GAME_SIZE ||
        snakeHead.y <= 0 || snakeHead.y >= LOGICAL_GAME_SIZE) {
      playerDies(playerState); 
      return;
    }
    
    // If the player collides with self, end their game
    var snakeHead = playerState.snakePieces[0];
    // skip first one so use a stupid loop
    for (var i = 1; i < playerState.snakePieces.length; i++) {
      var snakePiece = playerState.snakePieces[i];
      if(snakePiece.x === snakeHead.x && snakePiece.y === snakeHead.y) {
        playerDies(playerState);
        return;
      }
    }

    // check for collisions (apples)
    for (var i in playerState.apples) {
      var apple = playerState.apples[i];
      if (apple.x == playerState.snakePieces[0].x && apple.y == playerState.snakePieces[0].y) {
        playerState.apples.splice(i, 1);
        growSnake(playerState);
      }
    }

    // Stop draws
    gameContext.save();

    // Clear the field by painting black
    gameContext.fillStyle = "#000";
    gameContext.fillRect(0, 0, canvasSize, canvasSize);

    // Draw snakes
    for (var i in playerState.snakePieces) {
      var snakePiece = playerState.snakePieces[i];
      gameContext.fillStyle = "#0F0";
      gameContext.fillRect(snakePiece.x * featureSize, snakePiece.y * featureSize, featureSize, featureSize);
    }

    // Draw apples
    for (var i in playerState.apples) {
      var apple = playerState.apples[i];
      gameContext.fillStyle = "#F00";
      gameContext.fillRect(apple.x * featureSize, apple.y * featureSize, featureSize, featureSize);
    }

    // Allow draw
    gameContext.restore();

    setTimeout(gameLoop, FRAME_SPEED_MS);
  }

  /**
   * Gets a random location that is at least 3 squares from any existing stuff
   */
  function getRandomUnusedLocation(playerState) {
    var MIN_SPACE = 3;
    var randomLocation = {};

    do {
      randomLocation.x = Math.floor(Math.random() * LOGICAL_GAME_SIZE);
      randomLocation.y = Math.floor(Math.random() * LOGICAL_GAME_SIZE);

      var collision = false;

      // Check existing game pieces
      // TODO: consider decoupling this from game representation
      var gamePieces = playerState.snakePieces.concat(playerState.apples);

      for (var i in gamePieces) {
        var gamePiece = gamePieces[i];
        if (gamePiece.x - MIN_SPACE <= randomLocation.x && gamePiece.x + MIN_SPACE >= randomLocation.x &&
            gamePiece.y - MIN_SPACE <= randomLocation.y && gamePiece.y + MIN_SPACE >= randomLocation.y) {
          collision = true;
          break;
        }
      }
    } while (collision);
    return randomLocation;
  }

  /**
   * Add 1 segment to the player's snake (on top of existing tail)
   */
  function growSnake(playerState) {
    var newPiece = {};
    newPiece.x = playerState.snakePieces[playerState.snakePieces.length - 1].x;
    newPiece.y = playerState.snakePieces[playerState.snakePieces.length - 1].y;
    playerState.snakePieces.push(newPiece);
  }

  function playerDies(playerState) {
    playerState.isDead = true;
    if(confirm("you died! Final score: " + playerState.snakePieces.length + "Play again?")) {
      initGame();
    }
  }
  
  /**
   * Scale the canvas to fit the screen to match these constraints:
   * - Canvas must be square
   * - Leave enough room under for a peek at leaderboard and mobile touch controls
   * - Leave a little margin on the sides
   */
  function scaleCanvas() {
    var BOTTOM_PADDING = 200;
    var SIDE_PADDING = 20;

    var windowHeight = $(window).height();
    var windowWidth = $(window).width();
    console.log("viewport " + windowWidth + "x" + windowHeight);

    var size;
    adjustedHeight = windowHeight - BOTTOM_PADDING;
    adjustedWidth = windowWidth - SIDE_PADDING;

    if (adjustedHeight < adjustedWidth) {
      size = adjustedHeight;
    } else {
      size = adjustedWidth;
    }

    // TODO: refactor this coupling out
    var $gameCanvas = $("#game-canvas");
    $gameCanvas.height(size).width(size);
  }
});
</script>
</head>
<body>
<div class="container">
  <canvas id="game-canvas" height="500" width="500"></canvas>
  <footer>
    <dl id="leaderboard">
      <dt>Jenny Tong</dt>
      <dd>100</dd>
      <dt>Jenny Tong</dt>
      <dd>100</dd>
      <dt>Jenny Tong</dt>
      <dd>100</dd>
    </dl>
    <div id="touch-controls"></div>
  </footer>
</div>
</body>
</html>